// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel kPerlin
#pragma kernel kFBM
#pragma kernel kOaxoaSubtractiveFBM
#pragma kernel kDomainWarpingFBM
#pragma kernel kMaxMin
#pragma kernel kBailout
#pragma kernel kHybrid

#define threadGroupSize 64

struct PointInput
{
	float3 pos;
};

struct PerlinOutput
{
	float val;
};

RWStructuredBuffer<PointInput> points;
RWStructuredBuffer<PerlinOutput> values;
	
static uint permutation4[128] = {
1535746199, 226692954, 895508425, 3775392194, 510076044, 1661505093, 169209893, 2483469847,
1273657591, 1053104640, 3420191838, 537600885, 1478603065, 1463326189, 2289898670, 2940512427,
2252842314, 2786799755, 3885929037, 2061856595, 3867530044, 693922268, 687156791, 915367668,
2705267009, 1230034945, 3146009809, 2836552144, 2189935816, 1453309044, 3329057956, 1073986221,
4209170740, 3389356924, 2121700134, 3562361599, 3812347599, 289017903, 706526646, 3584735199,
43579511, 1185126956, 2607127005, 162278311, 4247197313, 1852596755, 3907023183, 1752218034,
3831625434, 3253871355, 210817774, 4053971903, 3952161617, 1810829049, 534167601, 2641020853,
2966181048, 758282611, 4271244415, 1573776522, 490959582, 2381531160, 1112458112, 3030138327,

1535746199, 226692954, 895508425, 3775392194, 510076044, 1661505093, 169209893, 2483469847,
1273657591, 1053104640, 3420191838, 537600885, 1478603065, 1463326189, 2289898670, 2940512427,
2252842314, 2786799755, 3885929037, 2061856595, 3867530044, 693922268, 687156791, 915367668,
2705267009, 1230034945, 3146009809, 2836552144, 2189935816, 1453309044, 3329057956, 1073986221,
4209170740, 3389356924, 2121700134, 3562361599, 3812347599, 289017903, 706526646, 3584735199,
43579511, 1185126956, 2607127005, 162278311, 4247197313, 1852596755, 3907023183, 1752218034,
3831625434, 3253871355, 210817774, 4053971903, 3952161617, 1810829049, 534167601, 2641020853,
2966181048, 758282611, 4271244415, 1573776522, 490959582, 2381531160, 1112458112, 3030138327
};

static float3 rndvector = float3(28.9017903, 53.7600885, 49.0959582);
	
float fade (float t)
{
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}
	
float grad (int hash, float x, float y, float z)
{
	int h = hash & 15;
	float u = h<8 ? x : y;
	float v = h<4 ? y : h==12||h==14 ? x : z;
	return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
}

uint p4i (uint index)
{
	uint u = index / 4;
	uint b = index % 4;
	return (permutation4[u] & (255 << b*8)) >> b*8;
}
	
float perlin (float3 p)
{
	uint3 i = uint3( int(floor(p.x)) & 255, int(floor(p.y)) & 255, int(floor(p.z)) & 255 );

	float3 f = p-floor(p);
	
	float u = fade(f.x);
	float v = fade(f.y);
	float w = fade(f.z);
	
	uint A  = (p4i(i.x) + i.y);
	uint AA = (p4i(A) + i.z);
	uint AB = (p4i(A+1) + i.z);
	uint B  = (p4i( i.x+1 ) + i.y);
	uint BA = (p4i(B) + i.z);
	uint BB = (p4i( B+1 ) + i.z);
	
	return lerp(lerp(lerp(grad(p4i(AA), f.x  , f.y  , f.z   ),  
                          grad(p4i(BA), f.x-1.0, f.y  , f.z   ),
						  u), 
                     lerp(grad(p4i(AB), f.x  , f.y-1.0, f.z   ),  
                          grad(p4i(BB), f.x-1.0, f.y-1.0, f.z   ),
						  u),
					 v),
                lerp(lerp(grad(p4i(AA+1), f.x  , f.y  , f.z-1.0 ),  
                          grad(p4i(BA+1), f.x-1.0, f.y  , f.z-1.0 ),
						  u), 
                     lerp(grad(p4i(AB+1), f.x  , f.y-1.0, f.z-1.0 ),
                          grad(p4i(BB+1), f.x-1.0, f.y-1.0, f.z-1.0 ),
						  u),
				     v),
				w);	
}

float fbm (float3 p, int octaves, float persistence)
{
	float v = 0.0;
	float3 t = p;
	
	for (int octave = 0; octave < octaves; octave++)
	{
		v += perlin(t)*pow(2.0, -octave*persistence);
		t *= 2.0;
	}
	
	return v;
}

float oaxoa (float3 p, int octaves, float persistence, int iterations)
{
	float v = abs(fbm(p, octaves, persistence));
	
	for (int i = 0; i < iterations; i++)
		v = abs(v - fbm(p + 10.0*float3(i+1, i+1, i+1), octaves, persistence));
	return v;
}

float domainWarping (float3 p, int octaves, float persistence, int iterations)
{
	float3 v = p;
	float3 offset = float3(0.315, 1.781, 3.917);
	
	for (int i = 0; i < iterations; i++)
	{
		v = float3( fbm(4.0*v + offset*(i+1), octaves, persistence), fbm(4.0*v + 2.0*offset*(i+1), octaves, persistence), fbm(4.0*v + 3.0*offset*(i+1), octaves, persistence) );
	}
	return fbm(p + v, octaves, persistence);
}

float maxmin (float3 p, int octaves, float persistence, int iterations)
{
	float v = 0.0;
	float3 t = p;
	for (int i = 0; i < iterations; i++)
	{
		float f = fbm(t, octaves, persistence);
		if (v < 0.0)
		{
			if (f < v)
				v = f;
		}
		else
		{
			if (f > v)
				v = f;
		}
		t += float3(0.315, 1.781, 3.917);
	}
	return v;
}

float3 fbmvector (float3 p, int octaves, float persistence)
{
	return float3(fbm(p, octaves, persistence), fbm(p+rndvector, octaves, persistence), fbm(p+2.0*rndvector, octaves, persistence));
}

float bailout (float3 p, int octaves, float persistence, int iterations)
{
	float3 t = p;
	for (int i = 0; i < iterations; i++)
	{
		t += fbmvector(t, octaves, persistence);
	}
	return length(t-p);
}

float hybrid (float3 p, int octaves, float persistence)
{
	float3 t = p;
	float v = 0.7+perlin(p);//(1.0 - abs(perlin(p)));
	float w = v;
	
	for (int octave = 1; octave < octaves; octave++)
	{
		if (w > 1.0) w = 1.0;
		
		float a = (0.7+perlin(t)) * pow(2.0, -octave*persistence);
		v += w*a;
		w *= a;
		t *= 2.0;
	}
	
	return v;
}

[numthreads(threadGroupSize,1,1)]
void kPerlin (uint3 id : SV_DispatchThreadID)
{
	values[id.x].val = perlin(points[id.x].pos);
}

[numthreads(threadGroupSize,1,1)]
void kFBM (uint3 id : SV_DispatchThreadID)
{
	values[id.x].val = fbm(points[id.x].pos, 10, 0.75);
}

[numthreads(threadGroupSize,1,1)]
void kOaxoaSubtractiveFBM (uint3 id : SV_DispatchThreadID)
{
	values[id.x].val = oaxoa(points[id.x].pos, 10, 0.75, 10);
}

[numthreads(threadGroupSize,1,1)]
void kDomainWarpingFBM (uint3 id : SV_DispatchThreadID)
{
	values[id.x].val = domainWarping(points[id.x].pos, 10, 1.0, 3);
}

[numthreads(threadGroupSize,1,1)]
void kMaxMin (uint3 id : SV_DispatchThreadID)
{
	values[id.x].val = maxmin(points[id.x].pos, 10, 1.0, 20);
}

[numthreads(threadGroupSize,1,1)]
void kBailout (uint3 id : SV_DispatchThreadID)
{
	values[id.x].val = bailout(points[id.x].pos, 10, 1.0, 10);
}

[numthreads(threadGroupSize,1,1)]
void kHybrid (uint3 id : SV_DispatchThreadID)
{
	values[id.x].val = hybrid(points[id.x].pos, 20, -0.05);
}